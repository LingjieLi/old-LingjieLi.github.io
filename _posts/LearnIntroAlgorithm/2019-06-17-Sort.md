---
layout: post
title: "排序算法"
data: 2019-06-17 09:54:36
categories: IntroduceAlgorithm(算法导论)
tags: 排序
excerpt: 九种内部排序算法
author: Lydia
mathjax: true
---


* content
{:toc}

## **排序算法**
给一列元素排序算是算法中一个基础问题。排序算法可分为两种，**内部排序**和**外部排序**，内部排序是所有数据能够一次加入内存中，直接进行排序的算法；外部排序是指数据不能够一次加载到内存中，例如数据量太大等，这时候就需要采取一些办法。当我们讨论一个排序算法时，除了需要讨论**稳定性**，最好**时间复杂度**，最差**时间复杂度**和**空间复杂度**，还应该去讨论算法的适用范围和改进点，也就是在什么时候会出现最好时间复杂和最坏时间复杂度以及改进策略，通常算法的最坏事件复杂度发生在待排元素完全逆序的时候。另外，没有一种排序算法是在所有情况下都是最好的，选择合适的排序算法才是最重要的。算法的稳定性并不是一成不变的，例如插入排序中，我们使用严格小于/严格大于时，才能保证算法稳定，当使用小于等于/大于等于时，算法就是不稳定的。

为了方便讨论，我们只讨论基于比较的排序(相对的面是什么？？？)，即所有的元素都是可比较的，并且假定排序的结果是从小到大的。
### **简单排序算法**
这三种排序算法特点是代码简单，容易实现，但是在性能上不是很好，但是 **1)** 可以作为高级排序算法中小规模数据时应用，**2)** 在此基础上改进，例如对希尔排序的子数组应用简单插入排序，堆排序是简单选择排序的高级版本。
#### **简单插入排序**
简单插入排序的主要思想是将元素插入到**合适**的位置，逐步构建有序序列。将元素分成两个部分，前半部分是有序的，后半部分是无序的。每次从后半部分取出一个元素，在有序序列中从后向前扫描**比较**，找到合适的位置**插入**。
可以把插入排序想象成抓牌的过程，通常我们左手拿牌，右手抓牌，每抓到一张牌，从右向左比较牌面大小，如果牌面大于抓到的牌，就将这张牌向右移动一个位置(留出一个空位)，当牌面小于等于抓到的牌时，就将抓到的牌放入。
- 简单插入排序的时间复杂度是`O(N^2)`
- 当待排序列是有序时，取得最好时间复杂度`O(N)`
- 在简单插入算法中，只需要申请临时变量即可，空间复杂度是`O(N)`
- 当保证严格小于/严格大于时，算法是稳定的  
##### 伪码 
**`insertion_sort(A, length)`**
```cpp
for j = 1 to length
    key = A[j]
    //将key 插入有序子序列序列A[0...j-1]
    i = j-1
    while i>0 && A[i] > key
        A[i+1] = A[i]
        i--
    A[i+1] = key
```
#### **简单选择排序**
#### **冒泡排序**
### **高级排序算法**
#### **希尔排序**
#### **堆排序**
#### **快速排序**
#### **归并排序**
#### **桶排序**
#### **计数排序**
#### **基数排序**

```cpp
#include <iostream>
```

